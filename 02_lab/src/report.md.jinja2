{{ header(2) }}

## Система

### Характеристики процессора:
```
{{ sh("sudo inxi -C") }}
```

### Характеристики памяти:
```
{{ sh("sudo inxi -m") }}
```

### Версия gcc:
```
{{ sh("gcc --version | head -n 1") }}
```

### Версия OpenMP:
```
{{ sh("./target/version") }}
```

### Остальные Характеристики
```
{{ sh("uname -rm") }}
```

## Оценка алгоритма

### Принцип работы
Приведенный алгоритм итерируется по массиву чисел и сравнивает их с заданным элементом target. Если элемент оказывается равен target то итерация завершается и выводится наименьший номер элемента в массиве через переменную index. Иначе, итерация продолжается. Если элемент не был найден индекс останется равным -1. 

### Блок-схема

```mermaid
    %%{ init : {"flowchart" : { "curve" : "stepAfter", "diagramPadding" : 20 }}}%%
    graph TD
        A(Начало) --> B(i: 0 -> n)
        
        B --> C{"array[i] == target"}
        C -->|Да| D["index = i"]
        D --> E(выход)
        C -->|Нет| B
```

### Оценка временной сложности

- Лучший случай: O(1)
- Худший случай: O(n)
- Средний случай: O(n)


### Директивы OpenMP
```c
#pragma omp parallel for shared(array, count, chunk) default(none) private(i) schedule(dynamic, chunk) num_threads(threads)
```

Задается обасть параллельного цикла, с количеством тредов `threads`. Переменные `array`, `count` и `chunk` объявляются общими для всех тредов и непараллельной части алгоритма. Все новые переменные без явного указания класса не разрешены. Цикл выполняется dynamic образом с размером чанка chunk - это значит, что каждый раз когда определенный тред закончит выполнение своей части цикла, ему выдадется новые chunk итераций.
Область - __цикл for генерации массива__.
Эта директива необходима для того, чтобы массив генерировался быстрее.

```c
#pragma omp parallel for shared(array, count, target) default(none) private(i) num_threads(threads) reduction(min: index)
```

Задается обасть параллельного цикла, с количеством тредов threads. Переменные array, count и target объявляются общими для всех тредов и непараллельной части алгоритма. Все новые переменные без явного указания класса не разрешены. Переменная i объявляется индивидуальной для каждого треда. reduction с опцией min - будет выбирать минимальный индекс из каждого, что нашел каждый тред по отдельности.
Область - цикл for
Эта директива необходима для распараллеливания поиска первого индекса и соответственно уменьшения времени его поиска, иначе бы цикл последовательно выполнил count итераций.

### Экспериментальные данные

Среднее время исполнения последовательного алгоритма: 0.00560691 секунд.

#### Среднее время, ускорение и эффективность

![image](graphs/AvgTime.png)

Ускорение работы программы по сравнению с однопоточной версией

![image](graphs/Acceleration.png)

Эффективность работы программы

![image](graphs/Efficiency.png)

## Выводы
На устройстве, на котором проходило тестирование - 4 физических ядра, из-за чего значительный
и вплоть до 4 ядер ожидаемое время исполнения совпадает с экспериментальными данными. На 7 потоках мы видим резкое уменьшение эффективности,
которое не будет сглажено. Вероятно из-за cache miss'ов.

## Исходный код

### Последовательная версия
```c 
{{ sh('cat src/serial.c') }}
```

### Параллельная версия
```c 
{{ sh('cat src/parallel.c') }}
```


