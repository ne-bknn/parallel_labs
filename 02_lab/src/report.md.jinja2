{{ header(1) }}

## Система

### Характеристики процессора:
```
{{ sh("sudo inxi -C") }}
```

### Характеристики памяти:
```
{{ sh("sudo inxi -m") }}
```

### Версия gcc:
```
{{ sh("gcc --version | head -n 1") }}
```

### Версия OpenMP:
```
{{ sh("./target/version") }}
```

### Остальные Характеристики
```
{{ sh("uname -rm") }}
```

## Оценка алгоритма

### Принцип работы
Приведенный алгоритм итерируется по массиву чисел и сравнивает их с заданным элементом target. Если элемент оказывается равен target то итерация завершается и выводится наименьший номер элемента в массиве через переменную index. Иначе, итерация продолжается. Если элемент не был найден индекс останется равным -1. 

### Блок-схема

```mermaid
    %%{ init : {"flowchart" : { "curve" : "stepAfter", "diagramPadding" : 20 }}}%%
    graph TD
        A(Начало) --> B(i: 0 -> n)
        
        B --> C{"array[i] == target"}
        C -->|Да| D["index = i"]
        D --> E(выход)
        C -->|Нет| B
```

### Оценка временной сложности

- Лучший случай: O(1)
- Худший случай: O(n)
- Средний случай: O(n)


### Оценка сложности алгоритмы

$p$ - количество используемых потоков  
$n$ - длина обрабатываемой последовательности

Тогда, сложность алгоритма - $O(\frac{n}{p})$; в частности, при $p = 1$, сложность - $O(n)$.

Теоретическое, ускорение работы программы - $p$.

### Директивы OpenMP
```c
#pragma omp parallel for shared(array, count, chunk) default(none) private(i) schedule(dynamic, chunk) num_threads(threads)
```

Задается обасть параллельного цикла, с количеством тредов `threads`. Переменные `array`, `count` и `chunk` объявляются общими для всех тредов и непараллельной части алгоритма. Все новые переменные без явного указания класса не разрешены. Цикл выполняется dynamic образом с размером чанка chunk - это значит, что каждый раз когда определенный тред закончит выполнение своей части цикла, ему выдадется новые chunk итераций.
Область - __цикл for генерации массива__.
Эта директива необходима для того, чтобы массив генерировался быстрее.

```c
#pragma omp parallel for shared(array, count, target) default(none) private(i) num_threads(threads) reduction(min: index)
```

Задается обасть параллельного цикла, с количеством тредов threads. Переменные array, count и target объявляются общими для всех тредов и непараллельной части алгоритма. Все новые переменные без явного указания класса не разрешены. Переменная i объявляется индивидуальной для каждого треда. reduction с опцией min - будет выбирать минимальный индекс из каждого, что нашел каждый тред по отдельности.
Область - цикл for
Эта директива необходима для распараллеливания поиска первого индекса и соответственно уменьшения времени его поиска, иначе бы цикл последовательно выполнил count итераций.

### Экспериментальные данные

Время работы программы при различном количестве потоков

![image](target/threads.png)

Ускорение работы программы по сравнению с однопоточной версией

![image](target/acceleration.png)

Эффективность работы программы

![image](target/efficiency.png)

## Выводы
На устройстве, на котором проходило тестирование - 4 физических ядра, из-за чего значительный
прирост программа показывает только при использовании 2 потоков. Вплоть до 8 потоков скорость выполнения
уменьшается, но с сильным отрывом от теоретической скорости выполнения. Использование больше чем 8 потоков 
не дает прироста в скорости выполнения программы.

## Исходный код

```c 
{{ sh('cat src/main.c') }}
```
