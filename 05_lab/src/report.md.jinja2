{{ header(5) }}

## Система

### Характеристики процессора:
```
{{ sh("sudo inxi -C") }}
```

### Характеристики памяти:
```
{{ sh("sudo inxi -m") }}
```

### Версия gcc:
```
{{ sh("gcc --version | head -n 1") }}
```

### Версия OpenMPI:
```
{{ sh("mpirun --version") }}
```

### Остальные Характеристики
```
{{ sh("uname -rm") }}
```

## Оценка алгоритма

### Оценка временной сложности

$O(\displaystyle\frac{n}{p})$, n - количество элементов массива, p - количество потоков.

### Блок-схема
```mermaid
    graph TD
        %%{ init : {"flowchart" : { "curve" : "stepAfter", "diagramPadding": 20 }}}%%
        A(Начало) --> B(i: 0 -> n)
        
        B --> C{"array[i] > max"}
        B --> E(Выход)
        C -->|Да| D["max = array[i]"]
        C -->|Нет| B
        D --> B
```


### Экспериментальные данные

#### Время исполнения в сравнении с лабораторной #1

![image](target/avgtime.png)

#### Эффективность на поток

![image](target/acceleration.png)

#### Ускорение на поток

![image](target/efficiency.png)

## Выводы

Ознакомлен с технологией MPI. Была настроена рабочая среда, оценены метрики работы программы в зависимости от числа потоков. Проведен сравнительный анализ с аналогичной по задаче лабораторной работой #1, использующей технологию OpenMP.

Из-за высокого оверхеда в связи с необходимостью обмениваться сообщениями между рабочими процессами, использование OpenMPI для решения такой задачи не целесообразно. 

## Исходный код

```c 
{{ sh('cat src/main.cpp') }}
```

